#!/usr/bin/env bash

function parseOpcode()
{
	case "$1" in
		major | maj | M | x)
			echo "major"
			;;
		minor | min | m | y)
			echo "minor"
			;;
		patch | p | z)
			echo "patch"
			;;
		preview | pre)
			echo "pre"
			;;
		*)
			exit 1
			;;
	esac
}

OPCODE_DEFAULT=minor

# Begin code
case $# in
	0)
		OPCODE=$OPCODE_DEFAULT
		;;
	1)
		OPCODE=$(parseOpcode "$1")
		if [ -z "$OPCODE" ]
		then
			OPCODE="$OPCODE_DEFAULT"
			ID="$1"
		fi
		;;
	2)
		ID="$1"
		OPCODE=$(parseOpcode "$2")
		;;
esac

if [ -z "$ID" ]
then
	TAG_PREFIX=""
else
	TAG_PREFIX="$ID/"
fi

VERSION_RAW=$(git tag --list "${TAG_PREFIX}v*" --sort=-v:refname | head -n 1)
VERSION=${VERSION_RAW##*/}

if [ -z "$VERSION" ]
then
	case "$OPCODE" in
		pre)
			VERSION=v0.0.1
			;;
		*)
			VERSION=v0.0.0
			;;
	esac
fi

# Parse
REGEX='v\([[:digit:]]\+.[[:digit:]]\+.[[:digit:]]\+\)\(-pre.\([[:digit:]]\+\)\)\?'
PREFIX=$(echo $VERSION | sed "s/$REGEX/\1/g")
PREFIX=${PREFIX#v}
PRE=$(echo $VERSION | sed "s/$REGEX/\3/g")

DIGITS=(${PREFIX//./ })
MAJOR=${DIGITS[0]}
MINOR=${DIGITS[1]}
PATCH=${DIGITS[2]}

# Increment
case "$OPCODE" in
	major)
		MAJOR=$((MAJOR+1))
		MINOR=0
		PATCH=0
		PRE=0
		;;
	minor)
		MINOR=$((MINOR+1))
		PATCH=0
		PRE=0
		;;
	patch)
		PATCH=$((PATCH+1))
		PRE=0
		;;
	pre)
		if [ -z "$PRE" ]; then
			PATCH=$((PATCH+1))
		fi
		PRE=$((PRE+1))
		;;
	noop)
		;;
	*)
		echo "Usage:"
		echo "	git bump [<prefix>] [major | minor | patch | pre]"
		exit -1
		;;
esac

# Compute tag string
TAG="${TAG_PREFIX}v$MAJOR.$MINOR.$PATCH"
if [ "$PRE" -gt 0 ]
then
	TAG="$TAG-pre.$PRE"
fi

# Print
eval "git tag $TAG"
if [ -z "$VERSION_RAW" ]
then
	printf "Version initialized to ${GREEN}$TAG${CLEAR}!\n"
else
	printf "Version bumped from ${YELLOW}$VERSION_RAW${CLEAR} to ${GREEN}$TAG${CLEAR}!\n"
fi
